## Preguntas

1. ¿Qué crítica le harías al protocolo de #estaHerido y #noEstaHerido? (en vez de tener solo el mensaje #estaHerido y hacer “#estaHerido not” para saber la negación)

#estaHerido y #noEstaHerido se podría simplificar en un solo mensaje, y que con solo negarlo o que no cumpla la condición y así retornar un objeto False, podría servirnos. Pero CABE ACOTAR que al tener ambos mensajes aporta visualización y hace nuestro código más legible. 

2. ¿Qué opinan de que para algunas funcionalidades tenemos 3 tests para el mismo comportamiento pero aplicando a cada uno de los combatientes (Arthas, Mankrik y Olgra)

Básicamente es código repetido, podríamos crear un combatiente y que sus hijos sean (Mankrik, Olgra y Arthas), pero  creemos que está diseñado de esta forma porque nos ayuda a visualizar mejor el problema para poder resolverlo y entender mejor los conceptos dados en clases, y asi poder manipular los objetos en base a los tests nos presentan.
 

3. ¿Cómo modelaron el resultado de haber desarrollado un combate? ¿Qué opciones consideraron y por qué se quedaron con la que entregaron y por qué descartaron a las otras?

Con respecto al modelo del objeto Resultado: A medida que íbamos avanzando con los tests de rondas, íbamos verificando si quedaban combatientes con vida, y en base a eso cuando alguno de los dos bandos se quedaban sin combatientes, se determinaba que el bando opuesto era el ganador. Si por alguna razón ninguno perdía, el resultado era indeterminado.

Opciones, descartes y decisión final: Inicialmente entendimos al leer los OrquestadorCombatesTest que había que usar el objeto resultado para asignar el resultado del propinado por el orquestador, básicamente lo vimos como un informador o un traductor del desarrollo del combate. al que le consultamos los resultados.

Se nos dificulto poner en práctica esta idea, y pudimos correr los OrquestadorCombatesTest sin necesidad de crear el objeto Resultado, pero sentíamos que se perdía la esencia del Assert, y de los que no se pedía. Pero en el medio de eso también nos dimos cuenta que solo devolvemos a los tests únicamente el bando ganador sin las rondas que fueron necesarias para generar dicho ganador, una vez solventado esto, se nos ocurrió crear un objeto hijo de OrquestadorCombatesTest el cual sería Resultado y así poder aplicar nuestra idea general, y tratar de no romper con el formato del test, Resultado hereda los mensajes de su padre y así también funciona como contenedor de la información necesaria para generarlos asserts, todo esto concentrando las características dentro del objeto resultado.


